1.usb的包类型不同,包含的域也不同.

2.地址域是在令牌包中存在的.设备地址寻址是7位.

3.帧号域存在于SOF(帧首)包中

#传输数据包时:
4.接收方只有在正确接收数据,且数据包的pid和自身期望一样时,才会toggle自身的pid.

5.发送方只有在收到了来自接收方有效的握手信号,才会toggle自身的pid.

6.一开始发送和接收方的数据包pid都是data0.

7.如果发送方的数据包由于通讯干扰或者噪声等原因(CRC不正确),使得没有被接收方正确接收,接收方恢复NAK,且不会切换下次期望数据包pid(比如为data0).

8.因为发送方收到的是NAK,而不是AK,所以也不切换下次发送时的pid(比如是data0).

9.在下一次数据包重传的时候还能保持彼此data pid的同步.

10.当ACK的传输被破坏时:

接收方正确接收到了发送方的数据,并且接收方pid由data0切换到data1(比如),从机在返回ack时,主机没有正确接收到,下次发的数据包pid还是data0(比如).

11.主机给从机发送数据包,从机收到了,回复ack,但因为pid对不上数据被忽略掉.

12.ACK返回给主机的时候,主机下次pid变为data1,接下来数据就同步了.

#传输数据包问题结束

13.不是设备想发数据就能发,一定是主机想要了(主机发送IN令牌),设备才能发数据.

14.USB设备收到IN令牌包后,硬件先查看设备地址和端点信息是否有效,再看此时设备的发送端点状态是否为valid,如果不是valid,表示应用程序还没有准备好发送数据,USB硬件会回复一个NAK或者STALL握手包,具体取决于该断电的status tx域的设置.

15.如果是valid,usb硬件会回复准备好的数据.

16.之后usb硬件会收到主机发送的握手包.

17.正确收到握手包后,
(1).usb硬件会toggle期望data包pid,
(2).还会把该端点的发送状态从valid变nak,如果主机马上发过来in令牌包,硬件自动回复nak(表示数据还没准备好).
(3).硬件会置位ctr_tx标志位.

18.如果ctr_tx中断使能,需要在中断处理函数中做如下操作:
(1).检查寄存器判断此次成功的IN transaction是发生在哪个端点上的.
(2).如果数据还没发送完成的话,得准备下一次要发送的数据,拷贝到对应的硬件发送缓冲区中,然后更新count_tx.
(3).软件重新把state_tx置位成valid状态.

19.当主机要向设备发送数据或者命令的时候,首先发送out或者setup令牌包,紧随数据包.

20.usb硬件收到OUT令牌包或者SETUP令牌包中寻址的设备地址后端点好信息有效,并且该接收端点的状态也是valid,表示该端点准备好接收数据.

于是硬件会把随后数据包中的内容放到该接收端点对应的硬件接收缓冲区.

并用该接收缓冲区的长度作为初始长度,每接收1字节初始长度自减,以此检测数据溢出.

数据接收完毕后,如果CRC无误,那么硬件回复主机一个ack握手包.如果crc有误,硬件置位err标志.

如果实际数据长度超过了缓冲区长度,硬件会自动停止写入,(永远不会覆盖到其他缓冲区的内容),硬件自动回复stall告知主机出问题了,不会产生中断.

如果刚才端点的接收状态不是valid,则根据status_rx中的设置,返回nak或者stall握手包.

21.一次成功的out transaction是以usb设备回复主机nak握手为标志之后.

之后硬件会翻转数据包pid,把端点的接收状态从valid改为nak,并设置ctr_rx标志.

22.在对应的中断处理函数中:
(1).软件检查是哪个端点上发生的out传输.
(2).从对应端点的硬件接收缓冲区中读取数据.
(3).当准备好下一次接收后,软件把状态设置为valid.

23.setup transaction和out transaction类似,当一个setup transaction正确完成后,硬件会产生中断.

比如setup transaction后跟的是out transaction.
ctr_rx中断处理函数处理:
(1).把设备端点0两个方向的状态都改成nak
(2).根据setup事务中的数据部分判断后续事务的传输方向.
(3).在使能随后的数据阶段之前,只要接下来的数据事务不是最后一个,则把不用的方向设置为stall,以免主机出其不意地改变传输方向.设备可以回复stall表示主机出错.把要用到的方向设置为valid.

之后的数据数据transaction中,依旧是一个方向处于valid/nak(nak是硬件自动设置),一个是stall不变,提示主机错误方向.

如果判断出接下来的数据包是最后一个数据包(status stage之前的),在下一次使能接收状态之前,把另一个不用的方向设置为nak,以免主机在最后一次out transaction结束后,立刻发出in令牌开启控制传输的status stage.

这个中断处理函数准备好需要发送的0长度数据包后,再把发送状态设置为valid.

24.如果先是in最后是out,要设置STATUS_OUT,手册里搜吧.
out transaction结束了再复位STATUS_OUT.

25.对于大数据量的传输,bulk类型可以最大化利用总线带宽.

如果USB设备之前的一批数据还未处理完成,下一批数据又到来了,数据就只能回复nak应答,主机只能重复刚才的数据传输.

这种重复的反复会降低数据吞吐率,因此硬件设计了双缓冲的特性.

26.一旦使能了某个端点的双缓冲,该端点本来收发的两个端点都用来做单向的数据传输.

有相应寄存器位(DTOG)表示当前是哪个缓冲区在使用,即usb上的数据放到哪个硬件缓冲区里,应用程序可以读取另外一个缓冲区的内容.

27.以end point1作为out方向的接收端点为例:

DTOG可能代表USB正在往哪个缓冲区里写,
SWBUF可能代表应用程序正在操作哪个缓冲区.

假设此时DTOG=1,SWBUF=0,表示应用程序可以读取编号0的缓冲区内容,而USB数据总线上的数据填充到编号1的缓冲区.

如果USB总线上的一次out transaction已经结束了,硬件会翻转DTOG=0,如果再来的out数据包,usb设备会自动回复nak信号,直到应用程序读取完成编号为0的缓冲区,软件翻转SWBUF=1.

如果usb总线上再来out数据包,由于此时DTOG=0,和SWBUF=1不同,因此可以正常接收数据到编号为0的缓冲区中了(这里说的是USB接收).

28.如果很快就处理完编号0缓冲区中的内容,在返回之前,应该软件翻转SWBUF=1(表示软件该处理编号1的缓冲区了,但是还没处理),等到USB总线对编号1的数据填充完毕,一次transaction就结束了.会硬件翻转DTOG=0(表示硬件下次会往编号0的缓冲区里写),并触发接收中断,应用程序此时根据swbuf的值=1去处理缓冲区1中的内容.

29.同步传输没有握手包,只有令牌包和数据包,并且不支持数据重传,他不会使用数据翻转序列DTOG,永远使用data0作为数据包的pid.

30.同步类型的端点总是使用双缓冲机制减轻应用程序的处理压力.

硬件访问的哪个缓冲区由DTOG位来指示.软件访问的缓冲区是DTOG没有指示的哪一个.

如果要实现双向的同步传输,需要两对双向端点的四个缓冲区了.

31.USB规范中定义了设备的一种特殊状态,叫做suspend挂起模式.
规范要求挂起模式下,设备从USB取电不超过2.5个毫安.

设备如何进入挂起模式?

主机只要3ms在总线上没有任何活动(sof包).

设备检测到连续三个sof包没有收到,就认为主机要求他挂起.

这时硬件会置位相应标志并产生中断.

挂起模式下设备还是能够检测USB总线发出的reset序列和resume序列.

resume序列可以由设备发起(远程唤醒)也可以主机发起.