一.  

1.特点:基于页进行读写,基于块进行擦除,便宜,容量大.

2.简介: 一种非易失性存储器,内部采用非先行宏单位模式,为固态大容量内存的实现提供了廉价有效的解决方案.

3.常见的存储设备基本都是NAND FLASH,比如SD卡(加了一个控制器),u盘,emmc(有大脑,更好管理NAND FLASH),固态硬盘,手机存储.

4.特点:高存储密度,高速度,低功耗,长寿命,价格低廉.

5.存储数据的基本元件:浮栅场效应管.

采用Floating Gate存储数据的技术,信息存放在浮置栅极中,电荷量表示当前存储的数据情况.

对NAND FLASH写入,就是在控制栅极施加正向电压,电子通过隧道氧化层进入到浮置栅极,超过阈值Vth就表示0.

读NADN FLASH擦除,就是在衬底施加正向电压,对浮置栅极放电,低于阈值就表示1.

如果频繁进行擦除或者写入,有损耗可能会氧化,擦除和写入就不灵敏了.这个单元就失效了,称为坏块.

6.写入后,浮置栅极电子多,表示0;擦除后,浮置栅极电子少,表示1.

7.有字符线和位线,字符线表示当前读取的是第几个字节;位线表示当前读取第几个位.

8.存储颗粒分类.

SLC:区分1位.0,1.(这个贵点)

MLC:区分2位.00,01,10,11.

TLC:区分三位

9.STM32控制器仅支持SCL类型的.

10.引脚.(#代表低电平有效)

CE#:片选.
CLE(Command latch enable):命令锁存使能,表示当前写入的是命令.
ALE:地址锁存使能,表示写入的是地址
WE#:写使能,用于写入数据.
RE#:读使能,用于读取数据.
WP#:写保护.
IOx:地址/数据 输入/输出端口.
R/B:就绪/忙,判断编程/擦除操作是否完成.

发送命令:CLE有效,ALE无效.
发送地址:ALE有效,CLE无效.
发送数据:两个都无效.

11.组成.

以MT29F4G08为例.

由2个plane组成.
每个plane由2048个块组成.  一共4096个块.
每个块由64页组成.
一页由(2048+64)字节组成.
2048:数据存储区,存放有效数据.
64:备用存储区(spare 区域),存放ECC校验值,实现坏块管理和磨损均衡.

磨损均衡:这么多块不能一直对一个块进行读写,得均衡的使用.优先使用那个操作次数少的,延长使用寿命.

字节是数据读写的最小单位,块是擦除的最小单位.

12.寻址.

对指定地址数据进行读写.

地址分三类:

块地址,页地址,列地址.

对于MT29F4G08,这三个地址通过5个周期发送,首先发送列地址,再发送页地址和块地址.

CA0~CA11表示列地址,用于page内部寻址,器件的page为2112字节,需要12跟地址线.

所以第一次发CAx的低八位,第二次发CAx的高四位,高位补零.这里用了两个字节空间.

PA0~PA5,表示页地址,用于在一个Block内部寻址,器件的Black为64个page.六根地址线.

BA6~BA17表示块地址,用于块寻址,器件总共4096个Block,需要12跟地址线.

所以第三次低位是PA0~5六位,高两位发BA6~BA7.

第四次发BA8~BA15. 第五次发BA16~BA17.高六位补0.

计算物理地址:块大小*第几个块+页大小*页号+页内地址.

例子:第100个块中第64页中的1208字节处的地址.
128K*100+2k*64+1208=0xca04b8.
实际上这样不对.

由于存在SPARE区域,读数据需要跳过这些地址,所以需要对NAND FLASH地址做一些转换.

正确:

获取页内地址:1208=0x4b8.
把块转化为以页为单位: 128k/2k*100+64=0x1940.
正确地址是:0x1940 04b8.

spare区如何访问?

页内地址:2048=0x800
页地址:128k/2k*100+64=0x1940.
所以就0x1940 0800.

13.写入长度大于ECC的页大小,需要写入ECC的值.

可以选择要对多大一片内存进行ECC.

eg:
设置对256字节计算一个ECC值.
写入长度是512字节,大于256字节,需要在备用区写ECC值.

写数据时,先擦除block(擦除后Block数据全为1),才可以写入0.

14.对NAND内部进行数据移动,对于块管理和磨损平衡特别有用.
只能在一个plane中进行拷贝.

15.FMC配置时需要关注的参数.

tCLR:发送完命令到数据输出需用时间.
tAR:发送完地址到数据输出需用时间.
tCLS/tALS:CLE/ALE信号建立时间.
tRP/tWP:读/写周期的低电平时间.
tCLH/tALH:CLE/ALE信号保持时间.

二.NAND FLASH难点.

16.

(1).坏块管理.(2).ECC校验(错误校验),都需要MCU解决.

NAND FLASH的应用,通常会把他类比成一个SD卡.给他植入一个文件系统(FATFS).从文件系统到NAND FLASH基础接口间有个FTL层(闪存转换层),在这个层面解决上述问题(1).NAND FLASH基础接口解决ECC校验的问题.

坏块标记和ECC校验信息都存放在Page的备用区域中(apare area).

需要对坏块进行识别和标记. 合理的分配和使用好的块,以最大限度延长NAND FLASH的寿命.

17.问题:NAND FLASH中某些块中特定位,隔了一段时间去读取,有可能原来存进去是1,而结果读出是0.

写入时先用算法计算到数据的ECC值,把ECC值和块内数据一并存入NAND FLASH中.

读取时,也是把块内数据和ECC一并读出,然后用相同的算法计算块内数据的ECC和ECC进行比较,如果不同就认为数据已经发生了变质.

18.坏块管理.

需要实现:
(1).如何识别坏块,标记坏块.
NAND厂家出厂时,会在每个Block的第一个Page和第二个Page的spare区的第一个字节写入非0xff值来表示这是坏块.0xff是好块.

通过给每个BLock写入数据(0xff/0x00),读出数据没变化,判断写入的数据和读取的一不一样,来识别坏块.

通过读取ECC错误,来识别坏块.
(2).转换表.

也称Lut表.

文件系统访问文件时,使用的是逻辑地址,是按顺序编号的,不考虑坏块的情况.

NAND FLASH存储地址时,称之为物理地址,是有可能存在坏块的.

文件系统中的逻辑地址与NAND FLASH中的物理地址之间必须有一个映射表,将逻辑地址转换为物理地址.且不能指向坏块的物理地址.

映射表必须存储到NAND FLASH中,以便上电后重建.

当出现坏块就需要对坏块做标记.还得从保留区中提取一个未使用的块来代替坏块.

利用每个Block的第一个的第一个page的spare区来存储映射表,另外还需标记这个Block是否被利用.

备用区第一个字节表示是好块还是坏块.(0xff表示好块,0xaa表示坏块),第二个字节用来表示是否被占用.(0xff表示未被占用,0xcc表示已被占用)(自定义的,非官方),第三和第四个字节组合起来,用来表示该块映射的逻辑地址.(0xffff 表示未被分配).

新建一个数组进行存放.
uint16_t lut[LBNnum] = M ;
LBNnum逻辑地址;M:物理地址,映射表第LBNnum所对应的地址.

(3).保留区.

两个作用: 

产生坏块时,用来代替坏块.

复写数据时,用来替代被复写的块,提高写入速度,实现磨损均衡处理.

文件系统通常要往某个已经被写过的块里写入新数据,由于FLASH特性,先擦除后写入.

一般方法:读 - 改 - 擦 - 写.(非常耗时且需要非常大的内存,一个Block为128K)

解决:页拷贝指令.
将内部某个Block的数据以页为单位,拷贝到另一个block中,而且写入新的数据.

好处:无需读出整个block数据,在正确地址写入需要写入的新数据即可.

要求:需要足够多的空闲块来均分擦除次数,实现磨损均衡,


19.ECC校验,是一种对传输数据的错误检测和修正算法. NAND FLASH存储单元是串行组织的,当读取一个单元时,读出放大器所检测到的信号强度会被这种串行存储结构削弱,降低了所读信号的准确性导致读数出错(一般只有一个bit出错),ECC可以检测这种错误,并修正错误的数据位(自行处理).

常用三种算法:汉明码(Hamming Code),RS码(Reed Solomom Code)和BCH码.

STM32的FMC模块支持硬件计算ECC计算,使用的就是汉明码,可以检测处错误,但无法修正.

支持页大小按256,512,1024,2048,4096和8192字节为单位进行ECC计算. 

汉明码算法需要2n bit的ECC校验数据来处理2^n bit的数据包.

eg: 512 byte = 512 * 8 bit = 4096 bit = 2^12 .
所以 512byte 需要2 * 12 = 24 个位来存储ECC校验数据. 

汉明码:计算数据包得到2个ECC值(ECCo奇校验值和ECCe偶校验值).

一个字节数据可以1/2,1/4,1/8校验.
1/2校把数据均分为1组.
1/4校把数据均分为2组.
1/8校把数据均分为4组.
按顺序7 ~ 0.
每组均分右边的数据是偶,左边的是奇.
ECCe(偶校验):1/2偶四个数异或,1/4偶四个数异或,1/8偶四个数异或 = 3个数依次拼起来.
ECCo(奇校验):1/2奇四个数异或,1/4奇四个数异或,1/8奇四个数异或 = 3个数依次拼起来.

得到ECC值后,需要将原数据包和ECC数值写入NAND FLASH里, 读数据时ECC值会重新开始计算,对比可知数据有无异常.

原数据和读出数据的共四个ECC码按位异或,全为1表示(字节111)有1个bit出错了.

对于这种情况,出错的地址(哪一位)可通过新ECCo和原ECCo按位异或得到,这位取反得到正确字节.

eg:出错数据 0101 0101 (假设第2位错了,从0起). 原数据  0101 0001.
(原数据)ECCx , (出错数据)nECCx

temp = ECCe ^ ECCo ^ nECCe ^ nECCo 
     = 101  ^ 010  ^ 000   ^ 000
     = 111(表示有1个bit出错了)

ECCo ^ nECCo = 010 ^ 000 = 010 ,所以第二个位出问题了. 取反一下得到了0101 0001.

ECC值存放在NAND FLASH中,从每个Page的spare区的第16个字节(地址0x10)开始存放.

由于对512字节进行ECC需要24bit,3个字节,为了方便运算,给他四个字节. 

1页当中,
16:19这4个字节表示0~511字节的校验码,
20:23这4个字节表示512~1023字节的校验码,
24:27这4个字节表示1024~1535字节的校验码,
28:31这4个字节表示1536~2047字节的校验码,
就这样分配加上以前的分配,64字节的备用区也只用了一半.

写操作:STM32 FMC的硬件ECC会计算出ECC值,我们需要写到备用区对应地址.
读操作:STM32 FMC的硬件ECC会计算出一个新的ECC值,我们需要进行与原来的ECC值比对,判断数据是否有误,以及1bit数据纠正.

一般选择512字节是为了兼容文件系统,文件系统通常的操作单位就是512字节.如果读写的数据不是512字节的整数倍,不会进行ECC处理.