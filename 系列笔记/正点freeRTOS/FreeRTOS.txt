1.移植要点: 加文件,分好组,包含路径,按本本上来.

不要加正点原子usart那个文件.

正点原子例程里加sys

2.中断建议全抢占优先级,不带子优先级,freeRTOS方便管理.

3.vTaskDelay(1000);  这个函数会操作到中断,如果涉及开关中断,用正点原子那个延时.

4.临界段代码保护:所谓的临界段代码也叫临界区,是指那些不能被打断的代码段.

适用的场合如下:(1).外设:需要严格按照时序初始化的外设:IIC,SPI等.时序严格.

(2).系统自身需求 (3).用户自己

什么可以打断当前程序的运行? 中断,任务调度.

关中断,可以使任务调度也进行不了,因为任务调度本质用的是PendSV(最低优先级)中断.

freeRTOS在进入临界段代码的时候需要关闭中断,当处理完临界段代码后再打开中断.

taskENTER_CRITICAL()任务级进入临界段.
taskEXIT_CRITICAL()任务级进入临界段.
成对使用,支持嵌套:开头调用一次,结尾就调用一次;开头调用两次,结尾就调用两次;

taskENTER_CRITICAL_FROM_ISR()中断级退出临界段.
taskEXIT_CRITICAL_FROM_ISR()中断级退出临界段.
本质上就是开关中断.

要尽量保持临界区短.

强悍,因为就是关中断.

任务调度器的挂起和恢复:挂起任务调度器,调用此函数不需要关闭中断.
只是任务不切换了,中断照常响应.

vTaskSuspendALL() 挂起任务调度器,也支持嵌套
xTaskresumeAll() 恢复任务调度器 ,这个函数进入了临界区

5.内核进中断时自动压栈一部分寄存器值,出中断时自动出栈一部分寄存器值到CPU寄存器.

6.时间片调度简介.

(1).同等优先级任务轮流地享有相同的CPU时间(可设置),叫时间片,在FreeRTOS中,一个时间片就等于Systick中断周期.(1ms)

(2).一个时间片大小,取决于滴答定时器中断频率.

(3).没有用完(因为系统延时或者等待信号量)的时间片不会再使用,下次照样分配一整个时间片.

(4).需要把宏configUSE_TIME_SLICING和configUSE_PREEMPTION置1

7.freeRTOS使用队列主要流程:创建队列,写队列,读队列.

有动态创建和静态创建队列之分.

xQueueCreate() 动态方式创建队列,自动分配内存.
xQueueCreateStatic() 静态方式创建队列,手动分配内存.

xQueueCreate() 本质是个宏.参数:队列长度,队列项目大小.返回值NULL说明队列创建失败,其他值是队列句柄.

原型宏的参数有三个,前两个一样,第三个是选择功能,因为FreeRTOS基于队列做了别的功能比如信号量.

8.队列写入消息.

xQueueSend(),xQueueSendToBack(),xQueueSendToFront(),xQueueOverWrite()本质都是宏,只是指定了不同的写入位置.

本质都调用了xQuequeGenericSend()这个函数,参数:待写入的队列,待写入的消息,阻塞超时时间,写入的位置.
返回值:成功,pdTRUE.失败,errQUEUQ_FULL.

覆写方式写入队列,只有在队列的队列长度为1时,才能使用.

9.队列读.

xQueueReceive(),用于从队列中读取消息,并且消息读取成功后,会将消息从队列中移除.

3个参数:
xQueue,待读取的队列.
pvBuffer,信息读取缓冲区.
xTicksToWait,阻塞超时时间.

pdTRUE,读取成功.
pdFALSE,读取失败.

xQueuePeek(),不会移除已经读取的消息.

10.任务控制块里有什么(主要)?

(1).指向任务栈顶的指针.
(2).任务状态列表项.
(3).任务等待事件列表项.
(4).任务优先级
(5).任务栈的起始地址.
(6).任务的任务名字.
(7).指向任务栈栈底的指针.
(8).记录任务独自的临界区嵌套次数.

函数中的局部变量,函数调用时的现场保护和函数的返回地址等都是存放在栈空间的.

11.杂项
静态创建任务时,用户自行分配内存,作为任务的栈空间.

freeRTOS中的list有什么?
(1).列表中列表项的数量.
(2).一个用于遍历列表的指针.
(3).最后一个列表项.
