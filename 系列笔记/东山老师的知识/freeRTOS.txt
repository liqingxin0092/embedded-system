1.堆,就是专门用来动态申请内存,使用完再释放的.

用链表管理堆,搞内存管理的思路

每一片已经申请下来的空间前面带一个头数据,存的信息是管理空间的大小.myfree 通过将传入地址进行偏移来找到头数据,释放对应数量的空间.

堆中空闲空间,由链表管理.空闲的空间也有头数据,是个结构体,存的此空闲空间的大小,和下一片空闲空间的地址.

因为空闲地址(内存碎片)不连续,就用链表一直找.

2.前后台程序.

前台程序指:中断里的程序. 后台程序指:while(1)里的程序.

3.系统替代方案

每个功能函数里面都写成一个状态机.
每次进这个函数都只执行这个功能的一小部分.

4.栈是一块内存空间,CPU的SP寄存器指向它,它可以用于函数调用.

5.生成反汇编指令
模板:
fromelf --text -a -c --output=xx.dis xxx.axf

6.如果调用关系比较深,栈会一直往下生长,栈的每一截对应某部分函数的栈,见图24.

如果函数调用是并列的,表现在栈上就是分时复用的关系,栈地址上一样,时间不一样.

没有优化的局部变量保存在栈里,会多压入些寄存器预留位置.
优化了可能保存在寄存器里.

7.100ask.net这个网站里第七章FreeRTOS源码概述,讲解了一些命名规范,关于FreeRTOS的.


8.注意freeRTOS中分配栈的单位是字(4个字节),静态创建数组的时候要*4.

任务的栈取决于:任务中函数调用深度,和函数中局部变量的多少.
保存现场时保存在栈中CPU寄存器值固定16*4字节.

每层调用最多保存九个寄存器r4~r11,还有lr.每个寄存器四字节.

9.可以不同任务使用同一个任务函数,但这个函数不能操控一些全局变量或是静态变量.
参数可以传入全局变量,但是得不一样.

好处是省内存.

10.iic通信被打断可能出现问题.

不屏蔽中断如何进行保护?
不一定管用.
定义一个全局变量.

uint8_t g_is_available=1;//默认可用.

while(1)
{
	if(g_is_available)
	{
		g_is_available=0;//进行保护
		/*业务逻辑*/
		.......
		g_is_available=1;//取消保护
	}

}

这么写的缺陷在于:如果在判断flag与赋值flag=0期间发生tick调度,就导致被保护的逻辑被入侵了.当然概率很小.
11.
a.高优先级的任务未执行完,低优先级任务无法运行.
b.一旦高优先级任务就绪,马上运行.
c.最高优先级的任务有多个(优先级相同),他们轮流运行.

空闲任务优先级为0.

12.
假设任务1如果不是死循环,会进入一个错误函数(会让系统停止,里面是死循环).这是因为创建任务1,设置他的栈的时候把lr寄存器设置为那个错误函数的入口.
可以让任务执行完删除自己.

a任务给b任务删了,a来释放b的空间.
如果b任务自删,空闲任务释放b空间.释放PCB结构体释放栈.

如果高优先级任务一直执行,会导致空闲任务得不到执行,也就不能释放自删任务的内存,如果一直创建,一直自删,内存就不够用了.

有一种思想是:事件驱动型程序,就是发生什么事件才执行,此外一直保持空闲.

13.xTaskDelayUntil( &xLastWakeTime, xFrequency );//执行完一次后,会更新第一个参数的值,使得下一次执行这个函数有依据.
这个函数第一次执行的时候,是基于while(1)外面的xLastWakeTime = xTaskGetTickCount ();

14.警惕优化错误.

两个函数同时使用一个变量.一个对内存操作,一个对内核寄存器操作,就会出现优化错误.
把那个变量加volatile.

15.想要达到两个函数同步的目的,需要考虑怎样提高处理器的性能.
让那些等待的任务阻塞,不要让他们参与CPU的调度.
freeRTOS提供了很多同步的方法,使得正在等待其他任务的函数进入阻塞状态.

15.
freeRTOS首先通过互斥的方法保证正确性.
提供阻塞和唤醒的同步机制来提高效率.

16.
事件组:一个整数,每一位代表一个事件,做完了某件事情,就把某一位置为1. 其他任务可以等待某一个事件发生,也可以等待某几个事件发生.

信号量:做完一件事情,计数值加1,别的任务可以减这个值.

互斥量:如果把信号量的值只设置为0与1就成了互斥量,可用来保护某些资源.
会导致优先级反转,freeRTOS提出优先级集成这些方法来解决这些问题.

任务通知可以通知很多东西.

17.环形缓冲区

#define BUFFER_MAX  8;
int buffer[BUFFER_MAX];
int r=0,w=0;
int next_w=0;

void buffer_write(int val)
{
	if(next_w!=r)//如果未满
	{
		buffer[w]=val;
		w++;
		next_w=w+1;
		if(w==BUFFER_MAX)
			w=0;
		if(next_w==BUFFER_MAX)
			next_w=0;	
	}
}

int buffer_read()
{
	int val;
	if(w!=r) //如果非空
	{
		val=buffer[r];
		r++;
		if(r==BUFFER_MAX)
			r=0;
	}
	return val;
}

这种方式相对安全,因为都是各自改各自的指针,只限于一对一,不能多对多.

18.freeRTOS队列的本质.

freeRTOS队列的本质 就是一个唤醒缓冲区,增加了互斥措施,阻塞唤醒措施.
因为有了保护措施,可以增加一个变量统计队列中元素个数.
我们去写队列时,会让计数值累加;读队列时,会让计数值累减.

如果这个队列不传输数据,只修改那个计数值,就变成了信号量.

如果限制计数值最大值是1,就变成了互斥量.

19.等待队列期间任务阻塞不占CPU,让出CPU资源给其他任务.

如果是不同模块里的消息互通,就用队列.

可以是中断写队列,一个处理任务读队列,经过处理逻辑后,再写另外一个队列,再被另外一个任务读.

数据可以是结构体.注意使用的函数,fromisr.

20.硬件相关的驱动程序不应该和业务逻辑密切相关.

某个硬件驱动函数把硬件相关的信息写入一个队列,硬件数据怎么和业务产生关联,由另一个模块来实现. 

这样的话,以后更换了业务,只需要去修改中间层代码就可以了,硬件驱动代码还可以使用.

驱动层,中间层,业务层.

21.见图26,假设硬件数据来源于各个中断,硬件接收到了数据分别写队列,一个任务读那些队列,处理完再写队列给业务层.

22.不想把该文件的全局变量,函数暴露出去,加static.

读取变量就写个函数,uint8_t get_g_Val();
头文件包含这个函数.

把一些名称限制到这个.c .h文件中.

23.队列集框架.参考一下韦东山的代码.见图27.

创建队列集,把队列添加到队列集,从队列集中取出队列句柄,再从里面读数,不需要延时.


24.要确保 写队列操作 在 将队列加入到队列集 的后面.

就是先 把队列先都添加到队列集 再 写队列, 否则队列满了,没法写进去,也就无法写入队列集. 因为想要读取满了的队列,得通过队列集,队列集未响应,也就不能读满了的队列.

写队列的时候,如果队列属于某个队列集,会把队列的句柄写到其所属的队列集.

25.模拟互斥的操作.

uint8_t use=0;

void tast_a()
{
	while(use); //别人正在用
	use=1;//自己用
	/*业务逻辑a*/
	......
	use=0;//自己用完了

	osDelay(20);
}
void tast_b()
{
	while(use); //别人正在用
	use=1;//自己用
	/*业务逻辑b*/
	......
	use=0;//自己用完了

	osDelay(20);
}

26.队列的一种用法.

底层中断获取到一份数据,这一个数据重复写三次队列,使得三个任务可以各自读到一份相同的数据.

一种思想,由驱动程序把数据分发给不同的任务.

27.一种很重要的思想!!!

注册.

先把要操作的对象都注册到一个数组中,要记录注册表中的元素和数量.

然后由一个统一的操作函数操作这些已经注册的东西.

以后添加一个新的同类设备,就直接把他注册一下,操作函数就会操作到他.

28.信号量.

信号量是一个特殊的队列.

信号量:会加减计数值,但是不会涉及数据传输.
可以把他比喻成票,拿上票之后可以干活,干完活之后释放票.
高优先级任务先获得信号量.

二值信号量最大值为1,但是默认值是0,用的时候得手动give一下变1.

29.优先级反转.

低优先级任务take了信号量,此后中优先级任务运行,高优先级任务也take信号量,take不到,阻塞,中优先级任务运行.低优先级任务得不到运行,无法give信号量.

30.互斥量不会产生优先级反转问题.take了互斥量的任务优先级会被临时提拔到和等待互斥量的任务相当.

31.iic互斥使用也用互斥量.

33.事件组的引入.

信号量,互斥量,队列一次只能唤醒一个任务.

事件组(event group)可以一次唤醒多个任务.

有一个整数表示当前事件的发生情况.他的每一位表示一个事件.任务可以写事件组的对应位,表示事件发生或是没发生.

还有挂载的等待链表,如果一个事件没有发生是可以等待的.

自己任务的链表里一个整数,他的每一位表示一个事件.1代表这个事件发生了,0代表没发生.整数高八位表示想等待事件间的关系:是或还是与.可以配置自身这个任务是等待什么事件.

事件组每被任务写入了一次都会遍历链表,是否满足了这个任务的就绪条件,满足了就解除挂起链表.

34.